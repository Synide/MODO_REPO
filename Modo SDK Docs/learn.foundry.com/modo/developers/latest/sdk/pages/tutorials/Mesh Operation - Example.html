

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from learn.foundry.com/modo/developers/latest/sdk/pages/tutorials/Mesh Operation - Example.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 30 Nov 2024 03:16:08 GMT -->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mesh Operation - Example &mdash; Modo SDK 14.2v0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/js/contentui.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Mesh Operation - Manual implementation" href="Mesh%20Operation%20-%20Manual%20implementation.html" />
    <link rel="prev" title="Mesh Operation - Automatic implementation" href="Mesh%20Operation%20-%20Automatic%20implementation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Modo SDK
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://learn.foundry.com/modo/developers/latest/sdk/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Articles</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../starting/_starting.html">First Steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server_basics/_server_basics.html">Server Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../general/_general.html">Editorial Info</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ui/_ui.html">User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripting/_scripting.html">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faqs/_faqs.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">Code Examples</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="_tutorials.html">SDK Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Channel%20Mod%20Linear%20Blend.html">Channel Mod Linear Blend</a></li>
<li class="toctree-l2"><a class="reference internal" href="Channel%20Mod%20Math%20Multi.html">Channel Mod Math Multi</a></li>
<li class="toctree-l2"><a class="reference internal" href="Channel%20Mod%20Simple%20Kinematics.html">Channel Mod Simple Kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Color%20Model%20HSV.html">Color Model HSV</a></li>
<li class="toctree-l2"><a class="reference internal" href="Colormodel%20kelvin.html">Colormodel kelvin</a></li>
<li class="toctree-l2"><a class="reference internal" href="Command%20VertValue.html">Command VertValue</a></li>
<li class="toctree-l2"><a class="reference internal" href="Creating%20a%20Selection%20Set.html">Creating a Selection Set</a></li>
<li class="toctree-l2"><a class="reference internal" href="CustomView.html">CustomView</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hello%20World.html">Hello World</a></li>
<li class="toctree-l2"><a class="reference internal" href="HostService%20Reference.html">HostService Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="Io%20image%20raw.html">Io image raw</a></li>
<li class="toctree-l2"><a class="reference internal" href="Io%20scene%20geo.html">Io scene geo</a></li>
<li class="toctree-l2"><a class="reference internal" href="Io%20scene%20hgpl.html">Io scene hgpl</a></li>
<li class="toctree-l2"><a class="reference internal" href="Item%20Command%20Arguments.html">Item Command Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Item%20gasket.html">Item gasket</a></li>
<li class="toctree-l2"><a class="reference internal" href="Item%20mandelbrot.html">Item mandelbrot</a></li>
<li class="toctree-l2"><a class="reference internal" href="Item%20orb.html">Item orb</a></li>
<li class="toctree-l2"><a class="reference internal" href="Language%20Wrappers.html">Language Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mesh%20Operation%20-%20Automatic%20implementation.html">Mesh Operation - Automatic implementation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mesh Operation - Example</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bevel">Bevel</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#visitor">Visitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#offset">Offset</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mesh-operation">Mesh Operation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Class Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constructor">Constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Evaluate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compare">Compare</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert">Convert</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reevaluate">ReEvaluate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#server-tags">Server Tags</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#user-interface">User Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#command-help">Command Help</a></li>
<li class="toctree-l4"><a class="reference internal" href="#properties-form">Properties Form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#categories">Categories</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-code">The Code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plugin">Plugin</a></li>
<li class="toctree-l4"><a class="reference internal" href="#config">Config</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Mesh%20Operation%20-%20Manual%20implementation.html">Mesh Operation - Manual implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modo%20Version%20History.html">Modo Version History</a></li>
<li class="toctree-l2"><a class="reference internal" href="Movie%20cocoaqt.html">Movie cocoaqt</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiple%20Servers%20in%20One%20Module.html">Multiple Servers in One Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="Network%20Rendering.html">Network Rendering</a></li>
<li class="toctree-l2"><a class="reference internal" href="Package%20or%20Item%20Type%20(metaclass).html">Package or Item Type (metaclass)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Path%20Aliases.html">Path Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pattern%20Matching.html">Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="PlatformService%20Reference.html">PlatformService Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="Plug-ins%20vs.%20Scripts.html">Plug-ins vs. Scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pop-up%20List%20Choice.html">Pop-up List Choice</a></li>
<li class="toctree-l2"><a class="reference internal" href="Preference%20Forms.html">Preference Forms</a></li>
<li class="toctree-l2"><a class="reference internal" href="Prepare_Evaluate%20Protocol.html">Prepare/Evaluate Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="Preset%20Browser%20Filtering.html">Preset Browser Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="Preset%20Browser%20Paths.html">Preset Browser Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="Preview%20Socket.html">Preview Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="Procedural%20Geometry.html">Procedural Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20API%20Overview.html">Python API Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20Command%20Overview.html">Python Command Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20Notifier%20Example.html">Python Notifier Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20Samples.html">Python Samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20Treeview%20Example.html">Python Treeview Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Python%20in%20Modo.html">Python in Modo</a></li>
<li class="toctree-l2"><a class="reference internal" href="Query%20Command%20Values%20example.html">Query Command Values example</a></li>
<li class="toctree-l2"><a class="reference internal" href="RandomSel%20Script.html">RandomSel Script</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reading%20Files%20with%20Python.html">Reading Files with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reading%20Persistant%20Data.html">Reading Persistant Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reading%20UV%20Values.html">Reading UV Values in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="Render%20Frame%20Size.html">Render Frame Size</a></li>
<li class="toctree-l2"><a class="reference internal" href="Scene%20Query.cpp.html">Scene Query.cpp</a></li>
<li class="toctree-l2"><a class="reference internal" href="Select.typeFrom.html">Select.typeFrom</a></li>
<li class="toctree-l2"><a class="reference internal" href="Selection%20Operation%20-%20Automatic%20implementation.html">Selection Operation - Automatic implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Selection%20Operation%20-%20Manual%20implementation.html">Selection Operation - Manual implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Server%20Tags.html">Server Tags</a></li>
<li class="toctree-l2"><a class="reference internal" href="Singleton%20Listener.html">Singleton Listener</a></li>
<li class="toctree-l2"><a class="reference internal" href="Singleton%20Polymorph.html">Singleton Polymorph</a></li>
<li class="toctree-l2"><a class="reference internal" href="Startup%20Commands.html">Startup Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symbols%20defined%20in%20the%20lx%20package.html">Symbols defined in the lx package</a></li>
<li class="toctree-l2"><a class="reference internal" href="Texture%20test.html">Texture test</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tool%20spikey.html">Tool spikey</a></li>
<li class="toctree-l2"><a class="reference internal" href="Using%20Loader%20Options.html">Using Loader Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="Writing%20to%20the%20Event%20Log.html">Writing to the Event Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="Writing%20to%20the%20modo%20event%20log%20and%20debugger.html">Writing to the modo event log and debugger</a></li>
<li class="toctree-l2"><a class="reference internal" href="Your%20First%20Tool%20in%20Modo.html">Your First Tool in Modo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/_examples.html">Code Examples and Snippets</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python/python.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp/cpp.html">C++ Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Modo SDK</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="_tutorials.html">SDK Tutorials</a> &raquo;</li>
        
      <li>Mesh Operation - Example</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mesh-operation-example">
<h1>Mesh Operation - Example<a class="headerlink" href="#mesh-operation-example" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id3">Overview</a></p></li>
<li><p><a class="reference internal" href="#bevel" id="id4">Bevel</a></p>
<ul>
<li><p><a class="reference internal" href="#visitor" id="id5">Visitor</a></p>
<ul>
<li><p><a class="reference internal" href="#class-variables" id="id6">Class Variables</a></p></li>
<li><p><a class="reference internal" href="#evaluate" id="id7">Evaluate</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#offset" id="id8">Offset</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mesh-operation" id="id9">Mesh Operation</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id10">Class Variables</a></p></li>
<li><p><a class="reference internal" href="#constructor" id="id11">Constructor</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id12">Evaluate</a></p></li>
<li><p><a class="reference internal" href="#compare" id="id13">Compare</a></p></li>
<li><p><a class="reference internal" href="#convert" id="id14">Convert</a></p></li>
<li><p><a class="reference internal" href="#reevaluate" id="id15">ReEvaluate</a></p></li>
<li><p><a class="reference internal" href="#server-tags" id="id16">Server Tags</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#user-interface" id="id17">User Interface</a></p>
<ul>
<li><p><a class="reference internal" href="#command-help" id="id18">Command Help</a></p></li>
<li><p><a class="reference internal" href="#properties-form" id="id19">Properties Form</a></p></li>
<li><p><a class="reference internal" href="#categories" id="id20">Categories</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-code" id="id21">The Code</a></p>
<ul>
<li><p><a class="reference internal" href="#plugin" id="id22">Plugin</a></p></li>
<li><p><a class="reference internal" href="#config" id="id23">Config</a></p></li>
</ul>
</li>
</ul>
</div>
<p>__TOC__</p>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id3">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This sample plugin will demonstrate how to create a very simple mesh operation that bevels some selected polygons. The evaluation function will handle the creation of the geometry, and the re-evaluation function will handle subsequent evaluations that simply offset the beveled geometry along its normal.</p>
</div>
<div class="section" id="bevel">
<h2><a class="toc-backref" href="#id4">Bevel</a><a class="headerlink" href="#bevel" title="Permalink to this headline">¶</a></h2>
<p>The evaluation of the bevel is split into two separate operations, geometry creation and geometry offset. First, the new geometry is created in the same position as the original geometry, then the beveled polygons are offset along their normal. The point positions are cached after the geometry creation, so that in subsequent reevaluations we can easily apply a new offset to the original geometry position.</p>
<div class="section" id="visitor">
<h3><a class="toc-backref" href="#id5">Visitor</a><a class="headerlink" href="#visitor" title="Permalink to this headline">¶</a></h3>
<p>The creation of the beveled geometry is handled by a visitor that is evaluated for each “selected” polygon. The visitor performs a simple bevel operation by duplicating the polygon points, updating the polygon to use the new points, and then creating “side” polygons to connect the new points to the old points. The new point positions are cached, so that they can easily be enumerated when performing a incremental update.</p>
<div class="section" id="class-variables">
<h4><a class="toc-backref" href="#id6">Class Variables</a><a class="headerlink" href="#class-variables" title="Permalink to this headline">¶</a></h4>
<p>These three variables are initialised by the Mesh Operation when it instantiates the Visitor. The Polygon and Point objects are COM accessors that provide access to the elements, these types are automatically updated to point at the current element. The Vector is a cache of points that we create, so they can easily be enumerated by the incremental update.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">CLxUser_Polygon</span>          <span class="n">_polygon</span><span class="p">;</span>
<span class="n">CLxUser_Point</span>            <span class="n">_point</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">PointData</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_cache</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="evaluate">
<h4><a class="toc-backref" href="#id7">Evaluate</a><a class="headerlink" href="#evaluate" title="Permalink to this headline">¶</a></h4>
<p>This function is called for every “selected” polygon. Loop over the points on the polygon. For each point, we store the Position and Normal, then duplicate the point by calling the Copy method. The old and new points are stored in temporary lists, so that we can easily enumerate over them to generate the side polygons. The normal, position and new point is also stored in the incremental data cache. The position is cached before an offset is applied, as we always want the offset to be calculated as an absolute distance from its original position.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">_polygon</span><span class="p">.</span><span class="n">VertexCount</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pointCount</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pointCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">PointData</span>                <span class="n">pointData</span><span class="p">;</span>
        <span class="n">LXtPointID</span>               <span class="n">oldPoint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">LXtFVector</span>               <span class="n">position</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">_polygon</span><span class="p">.</span><span class="n">VertexByIndex</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldPoint</span><span class="p">)))</span>
        <span class="p">{</span>
                <span class="n">_point</span><span class="p">.</span><span class="n">Select</span> <span class="p">(</span><span class="n">oldPoint</span><span class="p">);</span>

                <span class="n">_point</span><span class="p">.</span><span class="n">Normal</span> <span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">pointData</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                <span class="n">_point</span><span class="p">.</span><span class="n">Pos</span> <span class="p">(</span><span class="n">position</span><span class="p">);</span>
                <span class="n">LXx_VCPY</span> <span class="p">(</span><span class="n">pointData</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>

                <span class="n">_point</span><span class="p">.</span><span class="n">Copy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pointData</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
                <span class="n">_cache</span><span class="o">-&gt;</span><span class="n">push_back</span> <span class="p">(</span><span class="n">pointData</span><span class="p">);</span>

                <span class="n">newPoints</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">pointData</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
                <span class="n">oldPoints</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">oldPoint</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Now the point has been copied and we’ve cached the point information, the polygon is updated to use the newly created points.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">_polygon</span><span class="p">.</span><span class="n">SetVertexList</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">newPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>We should have an identical number of new points and old points, so we loop over the points and create polygons from the old ones to the new ones. Note the use of NewProto to create the polygon, this ensures that the new polygon inherits properties such as material tags from the original polygon.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">oldPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">==</span> <span class="n">newPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">())</span>
<span class="p">{</span>
        <span class="n">pointCount</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pointCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">LXtPointID</span>               <span class="n">wallPoints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
                <span class="n">LXtPolygonID</span>             <span class="n">wallPolygon</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="n">wallPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">wallPoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPoints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">wallPoints</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPoints</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">pointCount</span><span class="p">];</span>
                <span class="n">wallPoints</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">pointCount</span><span class="p">];</span>

                <span class="n">_polygon</span><span class="p">.</span><span class="n">NewProto</span> <span class="p">(</span><span class="n">polygonType</span><span class="p">,</span> <span class="n">wallPoints</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wallPolygon</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="offset">
<h3><a class="toc-backref" href="#id8">Offset</a><a class="headerlink" href="#offset" title="Permalink to this headline">¶</a></h3>
<p>The offset calculation is really simple, we loop over the cached points and for each one, we multiply the normal by the offset and then add that back to the cached position, this then becomes the new position for the point.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_points</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">PointData</span>               <span class="o">*</span><span class="n">pointData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">LXtVector</span>                <span class="n">pos</span><span class="p">;</span>

        <span class="n">pointData</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">Select</span> <span class="p">(</span><span class="n">pointData</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)))</span>
        <span class="p">{</span>
                <span class="n">LXx_VCPY</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pointData</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">);</span>
                <span class="n">LXx_VSCL</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">_offset</span><span class="p">);</span>
                <span class="n">LXx_VADD</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pointData</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">);</span>

                <span class="n">point</span><span class="p">.</span><span class="n">SetPos</span> <span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="mesh-operation">
<h2><a class="toc-backref" href="#id9">Mesh Operation</a><a class="headerlink" href="#mesh-operation" title="Permalink to this headline">¶</a></h2>
<p>The evaluation of this mesh operation is split into two sections, Evaluate and ReEvaluate. Evaluate will create some initial beveled geometry, and for subsequent compatible evaluations, ReEvaluate will be called to simply offset the original beveled geometry along it’s normal. When operating on many elements, this separate ReEvaluation pass can improve performance significantly.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id10">Class Variables</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The offset amount and cache of newly created points are stored as public class variables. When we convert an old compatible mesh operation to a new mesh operation, we must copy the variables from the old mesh operation to the new one.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">double</span>                   <span class="n">_offset</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">PointData</span><span class="o">&gt;</span>  <span class="n">_points</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="constructor">
<h3><a class="toc-backref" href="#id11">Constructor</a><a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h3>
<p>In the Mesh Operation constructor, a single attribute that is used to control the offset distance is defined using DynamicAttributes. A default value of 0.0 is set, this will be used as the default channel value when the mesh operation server is converted into an item.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">dyna_Add</span> <span class="p">(</span><span class="s">&quot;offset&quot;</span><span class="p">,</span> <span class="n">LXsTYPE_DISTANCE</span><span class="p">);</span>
<span class="n">attr_SetFlt</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id12">Evaluate</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Evaluation is relatively lightweight, as it simply wraps the visitor and offset functions.</p>
<p>Grab the offset attribute and cache it. This will be used to later on to test if the mesh operation is compatible. If the offset is 0.0, we early out without performing the bevel.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">_offset</span> <span class="o">=</span> <span class="n">dyna_Float</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">==</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LXe_OK</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Perform the bevel by instantiating the visitor, initialising its class variables, then calling the Enumerate function to touch every selected polygon. The mode argument that is passed to Enumerate function allows us to easily enumerate over the selected elements and skip unselected polygons. Once the polygons are beveled, OffsetPositions is called to perform an offset on the newly created points that were cached in the Visitor. Finally, SetMeshEdits is called to inform the system of the geometry change. The entire evaluation is wrapped in a batch, which can provide improved performance in some cases.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">BeginEditBatch</span> <span class="p">()))</span>
<span class="p">{</span>
        <span class="n">visitor</span><span class="p">.</span><span class="n">_polygon</span><span class="p">.</span><span class="n">fromMesh</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
        <span class="n">visitor</span><span class="p">.</span><span class="n">_point</span><span class="p">.</span><span class="n">fromMesh</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
        <span class="n">visitor</span><span class="p">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_points</span><span class="p">;</span>

        <span class="n">visitor</span><span class="p">.</span><span class="n">_polygon</span><span class="p">.</span><span class="n">Enumerate</span> <span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">visitor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">OffsetPositions</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

        <span class="n">mesh</span><span class="p">.</span><span class="n">SetMeshEdits</span> <span class="p">(</span><span class="n">LXf_MESHEDIT_GEOMETRY</span><span class="p">);</span>
        <span class="n">mesh</span><span class="p">.</span><span class="n">EndEditBatch</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="compare">
<h3><a class="toc-backref" href="#id13">Compare</a><a class="headerlink" href="#compare" title="Permalink to this headline">¶</a></h3>
<p>In the compare function, the old mesh operation from a previous evaluation is passed in, and it should be tested to see if it’s cached state is compatible with the current properties of the mesh operation. A mesh operation is deemed compatible if the cached elements from the previous evaluation can simply be deformed to achieve an identical result to performing a full evaluation of the mesh operation.</p>
<p>lx::CastServer casts the old mesh operation COM interface into our internal implementation.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">lx</span><span class="o">::</span><span class="n">CastServer</span> <span class="p">(</span><span class="n">SERVER_NAME</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>If the current offset and previous offset are the same, we return LXiMESHOP_IDENTICAL to skip evaluation altogether. If either offset value was 0.0, then geometry in one of the evaluations will exist that won’t exist in the other, so we return LXiMESHOP_DIFFERENT to perform a full evaluation, otherwise we return LXiMESHOP_COMPATIBLE to perform an incremental update.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">LXiMESHOP_IDENTICAL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LXi_EQUAL_TO</span> <span class="o">&amp;&amp;</span> <span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">LXiMESHOP_COMPATIBLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">LXiMESHOP_DIFFERENT</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="convert">
<h3><a class="toc-backref" href="#id14">Convert</a><a class="headerlink" href="#convert" title="Permalink to this headline">¶</a></h3>
<p>If the previous evaluation was compatible, convert will be called to copy the point cache from the old mesh operation to the new one. We just copy values from one vector to another.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">lx</span><span class="o">::</span><span class="n">CastServer</span> <span class="p">(</span><span class="n">SERVER_NAME</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">_points</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">_points</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">_points</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="reevaluate">
<h3><a class="toc-backref" href="#id15">ReEvaluate</a><a class="headerlink" href="#reevaluate" title="Permalink to this headline">¶</a></h3>
<p>ReEvaluate is really simple, it just calls the OffsetPositions function which updates the position of the cached points.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">OffsetPositions</span> <span class="p">(</span><span class="n">mesh</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="p">.</span><span class="n">SetMeshEdits</span> <span class="p">(</span><span class="n">LXf_MESHEDIT_POSITION</span><span class="p">);</span>

<span class="k">return</span> <span class="n">LXe_FAILED</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="server-tags">
<h3><a class="toc-backref" href="#id16">Server Tags</a><a class="headerlink" href="#server-tags" title="Permalink to this headline">¶</a></h3>
<p>There are two server tags for this mesh operation, one specifies that the mesh operation should automatically be converted into an item, and the second specifies that the mesh operation supports polygon selections only.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">LXtTagInfoDesc</span> <span class="n">MeshOperation</span><span class="o">::</span><span class="n">descInfo</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
        <span class="p">{</span> <span class="n">LXsMESHOP_PMODEL</span><span class="p">,</span>             <span class="s">&quot;.&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">LXsPMODEL_SELECTIONTYPES</span><span class="p">,</span>     <span class="n">LXsSELOP_TYPE_POLYGON</span> <span class="p">},</span>
        <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="user-interface">
<h2><a class="toc-backref" href="#id17">User Interface</a><a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h2>
<p>Like the majority of the MODO user interface, the UI for mesh operations is defined through XML config files. Configs are explained in some depth <span class="xref std std-doc">./Category:Configs</span>.</p>
<div class="section" id="command-help">
<h3><a class="toc-backref" href="#id18">Command Help</a><a class="headerlink" href="#command-help" title="Permalink to this headline">¶</a></h3>
<p>The command help section is used to define the username of both the item and the items channels. Despite the server name being called “sample.bevel”, the item automatically generated from the mesh operation server has “.item” appended to the end, so all configs refer to the auto generated item as “sample.bevel.item”.</p>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;CommandHelp&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Item&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item@en_US&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Channel&quot;</span> <span class="na">key=</span><span class="s">&quot;enable&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Enable<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Channel&quot;</span> <span class="na">key=</span><span class="s">&quot;offset&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Offset<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/hash&gt;</span>
<span class="nt">&lt;/atom&gt;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="properties-form">
<h3><a class="toc-backref" href="#id19">Properties Form</a><a class="headerlink" href="#properties-form" title="Permalink to this headline">¶</a></h3>
<p>The properties form is defined using the “Attributes” block. The properties form contains a single control for displaying the offset channel, but also includes some common sheets to provide things like enable controls. The filter atom determines when the properties form should be displayed and is defined below.</p>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Attributes&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Sheet&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item:sheet&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Label&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Filter&quot;</span><span class="nt">&gt;</span>sample.bevel.item:filterPreset<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;InCategory&quot;</span> <span class="na">key=</span><span class="s">&quot;itemprops:general#head&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Ordinal&quot;</span><span class="nt">&gt;</span>110<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;ref item-common:sheet&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>#0<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;ref meshoperation:sheet&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>#1<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;cmd item.channel sample.bevel.item$offset ?&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Label&quot;</span><span class="nt">&gt;</span>Offset<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>sample.bevel.item.offset.ctrl:control<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;/list&gt;</span>
        <span class="nt">&lt;/hash&gt;</span>
<span class="nt">&lt;/atom&gt;</span>
</pre></div>
</td></tr></table></div>
<p>The filter can be used to control when a form is displayed. They are defined by name, and have various nodes which dictate the rules for when a form should be displayed, in this case it uses the itemtype filter. The itemtype filter checks if the sample.bevel.item is selected.</p>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Filters&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Preset&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item:filterPreset&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Name&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Description&quot;</span><span class="nt">&gt;&lt;/atom&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span><span class="nt">&gt;</span>pmodel:filterCat<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Enable&quot;</span><span class="nt">&gt;</span>1<span class="nt">&lt;/atom&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>1 .group 0 <span class="ni">&amp;quot;&amp;quot;</span><span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>1 itemtype 0 1 <span class="ni">&amp;quot;</span>sample.bevel.item<span class="ni">&amp;quot;</span><span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>-1 .endgroup <span class="nt">&lt;/list&gt;</span>
        <span class="nt">&lt;/hash&gt;</span>
<span class="nt">&lt;/atom&gt;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="categories">
<h3><a class="toc-backref" href="#id20">Categories</a><a class="headerlink" href="#categories" title="Permalink to this headline">¶</a></h3>
<p>When the user adds the mesh operation, the mesh operation items are displayed in a browser that is sorted by categories. If no category is defined by the plugin, it will appear in a category called “Other”, however this can be overridden with the following config fragment. The “MeshOperations” category is the master category that shows all mesh operations, and “polygon” is a sub-category under “MeshOperations”. Various selection types are also provided for Vertex and Edge mesh operations, if the mesh operation supports multiple selection types, the category will need to be defined for each type.</p>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Categories&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span> <span class="na">key=</span><span class="s">&quot;MeshOperations&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;C&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item&quot;</span><span class="nt">&gt;</span>polygon<span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/hash&gt;</span>

        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span> <span class="na">key=</span><span class="s">&quot;MeshOperationsPolygons&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;C&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item&quot;</span><span class="nt">&gt;</span>polygon<span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/hash&gt;</span>
<span class="nt">&lt;/atom&gt;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="the-code">
<h2><a class="toc-backref" href="#id21">The Code</a><a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h2>
<div class="section" id="plugin">
<h3><a class="toc-backref" href="#id22">Plugin</a><a class="headerlink" href="#plugin" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;lxsdk/lxidef.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;lxsdk/lx_mesh.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;lxsdk/lx_pmodel.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;lxsdk/lxu_attributes.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;lxsdk/lxu_math.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#define SERVER_NAME     &quot;sample.bevel&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *      The PointData structure is used to cache the incremental data for each point.</span>
<span class="cm"> *      It stores the element pointer, the non-offset position, as well as the normal.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="nc">PointData</span>
<span class="p">{</span>
        <span class="n">LXtPointID</span>               <span class="n">id</span><span class="p">;</span>
        <span class="n">LXtVector</span>                <span class="n">position</span><span class="p">;</span>
        <span class="n">LXtVector</span>                <span class="n">normal</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *      The polygon visitor performs the bevel operation for a single polygon. It</span>
<span class="cm"> *      creates new points at the same position as the points on the polygon it is</span>
<span class="cm"> *      beveling. The polygon is then updated to use the new points and &quot;wall&quot; polygons</span>
<span class="cm"> *      are added bridging the old and new points. The new point information is cached</span>
<span class="cm"> *      to that it can work with the incremental re-evaluation.</span>
<span class="cm"> */</span>

<span class="k">class</span> <span class="nc">PolygonVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CLxVisitor</span>
<span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
                <span class="n">PolygonVisitor</span> <span class="p">()</span> <span class="o">:</span> <span class="n">_cache</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

                        <span class="kt">void</span>
                <span class="n">evaluate</span> <span class="p">()</span>                     <span class="n">LXx_OVERRIDE</span>
                <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">LXtPointID</span><span class="o">&gt;</span> <span class="n">newPoints</span><span class="p">;</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">LXtPointID</span><span class="o">&gt;</span> <span class="n">oldPoints</span><span class="p">;</span>
                        <span class="n">LXtPolygonID</span>             <span class="n">polygon</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">LXtID4</span>                   <span class="n">polygonType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span>             <span class="n">pointCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                        <span class="n">polygon</span> <span class="o">=</span> <span class="n">_polygon</span><span class="p">.</span><span class="n">ID</span> <span class="p">();</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      For each point on the polygon, create a new point that</span>
<span class="cm">                         *      matches it&#39;s position. Add the point information to</span>
<span class="cm">                         *      the cache.</span>
<span class="cm">                         */</span>

                        <span class="n">_polygon</span><span class="p">.</span><span class="n">VertexCount</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pointCount</span><span class="p">);</span>

                        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pointCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                        <span class="p">{</span>
                                <span class="n">PointData</span>                <span class="n">pointData</span><span class="p">;</span>
                                <span class="n">LXtPointID</span>               <span class="n">oldPoint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                                <span class="n">LXtFVector</span>               <span class="n">position</span><span class="p">;</span>

                                <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">_polygon</span><span class="p">.</span><span class="n">VertexByIndex</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldPoint</span><span class="p">)))</span>
                                <span class="p">{</span>
                                        <span class="n">_point</span><span class="p">.</span><span class="n">Select</span> <span class="p">(</span><span class="n">oldPoint</span><span class="p">);</span>

                                        <span class="cm">/*</span>
<span class="cm">                                         *      Get the normal and position of the</span>
<span class="cm">                                         *      original point.</span>
<span class="cm">                                         */</span>

                                        <span class="n">_point</span><span class="p">.</span><span class="n">Normal</span> <span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">pointData</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                                        <span class="n">_point</span><span class="p">.</span><span class="n">Pos</span> <span class="p">(</span><span class="n">position</span><span class="p">);</span>
                                        <span class="n">LXx_VCPY</span> <span class="p">(</span><span class="n">pointData</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>

                                        <span class="cm">/*</span>
<span class="cm">                                         *      Copy the new point and store it in the</span>
<span class="cm">                                         *      cache.</span>
<span class="cm">                                         */</span>

                                        <span class="n">_point</span><span class="p">.</span><span class="n">Copy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pointData</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
                                        <span class="n">_cache</span><span class="o">-&gt;</span><span class="n">push_back</span> <span class="p">(</span><span class="n">pointData</span><span class="p">);</span>

                                        <span class="cm">/*</span>
<span class="cm">                                         *      Add the new and old points to a list</span>
<span class="cm">                                         *      so they can be enumerated to create</span>
<span class="cm">                                         *      the wall polygons.</span>
<span class="cm">                                         */</span>

                                        <span class="n">newPoints</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">pointData</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
                                        <span class="n">oldPoints</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">oldPoint</span><span class="p">);</span>
                                <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      Update the polygon to use the new points.</span>
<span class="cm">                         */</span>

                        <span class="n">_polygon</span><span class="p">.</span><span class="n">SetVertexList</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">newPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      Create &quot;wall&quot; polygons linking the old and new points.</span>
<span class="cm">                         */</span>

                        <span class="n">_polygon</span><span class="p">.</span><span class="n">Type</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">polygonType</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">oldPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">==</span> <span class="n">newPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">())</span>
                        <span class="p">{</span>
                                <span class="n">pointCount</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>

                                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pointCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                                <span class="p">{</span>
                                        <span class="n">LXtPointID</span>               <span class="n">wallPoints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
                                        <span class="n">LXtPolygonID</span>             <span class="n">wallPolygon</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                                        <span class="n">wallPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                                        <span class="n">wallPoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPoints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                                        <span class="n">wallPoints</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPoints</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">pointCount</span><span class="p">];</span>
                                        <span class="n">wallPoints</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldPoints</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">pointCount</span><span class="p">];</span>

                                        <span class="n">_polygon</span><span class="p">.</span><span class="n">NewProto</span> <span class="p">(</span><span class="n">polygonType</span><span class="p">,</span> <span class="n">wallPoints</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wallPolygon</span><span class="p">);</span>
                                <span class="p">}</span>
                        <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">CLxUser_Polygon</span>          <span class="n">_polygon</span><span class="p">;</span>
                <span class="n">CLxUser_Point</span>            <span class="n">_point</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">PointData</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MeshOperation</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CLxImpl_MeshOperation</span><span class="p">,</span> <span class="k">public</span> <span class="n">CLxDynamicAttributes</span>
<span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
                <span class="n">MeshOperation</span> <span class="p">()</span>
                <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         *      A single attribute is added to the mesh operation to</span>
<span class="cm">                         *      control the bevel offset. This attribute is converted</span>
<span class="cm">                         *      to a channel on the automatically generated item.</span>
<span class="cm">                         */</span>

                        <span class="n">dyna_Add</span> <span class="p">(</span><span class="s">&quot;offset&quot;</span><span class="p">,</span> <span class="n">LXsTYPE_DISTANCE</span><span class="p">);</span>
                        <span class="n">attr_SetFlt</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
                <span class="p">}</span>

                        <span class="n">LxResult</span>
                <span class="n">mop_Evaluate</span> <span class="p">(</span>
                        <span class="n">ILxUnknownID</span>             <span class="n">mesh_obj</span><span class="p">,</span>
                        <span class="n">LXtID4</span>                   <span class="n">type</span><span class="p">,</span>
                        <span class="n">LXtMarkMode</span>              <span class="n">mode</span><span class="p">)</span>                  <span class="n">LXx_OVERRIDE</span>
                <span class="p">{</span>
                        <span class="n">CLxUser_Mesh</span>             <span class="nf">mesh</span> <span class="p">(</span><span class="n">mesh_obj</span><span class="p">);</span>
                        <span class="n">PolygonVisitor</span>           <span class="n">visitor</span><span class="p">;</span>
                        <span class="n">LxResult</span>                 <span class="n">result</span> <span class="o">=</span> <span class="n">LXe_FAILED</span><span class="p">;</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      If the offset amount is 0.0, then we want to do nothing.</span>
<span class="cm">                         */</span>

                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">dyna_Float</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">==</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
                                <span class="k">return</span> <span class="n">LXe_OK</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">BeginEditBatch</span> <span class="p">()))</span>
                        <span class="p">{</span>
                                <span class="cm">/*</span>
<span class="cm">                                 *      Enumerate over the polygons and bevel each one.</span>
<span class="cm">                                 */</span>

                                <span class="n">visitor</span><span class="p">.</span><span class="n">_polygon</span><span class="p">.</span><span class="n">fromMesh</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
                                <span class="n">visitor</span><span class="p">.</span><span class="n">_point</span><span class="p">.</span><span class="n">fromMesh</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
                                <span class="n">visitor</span><span class="p">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_points</span><span class="p">;</span>

                                <span class="n">visitor</span><span class="p">.</span><span class="n">_polygon</span><span class="p">.</span><span class="n">Enumerate</span> <span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">visitor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

                                <span class="cm">/*</span>
<span class="cm">                                 *      Apply an offset to the beveled polygons.</span>
<span class="cm">                                 */</span>

                                <span class="n">OffsetPositions</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

                                <span class="n">mesh</span><span class="p">.</span><span class="n">SetMeshEdits</span> <span class="p">(</span><span class="n">LXf_MESHEDIT_GEOMETRY</span><span class="p">);</span>
                                <span class="n">mesh</span><span class="p">.</span><span class="n">EndEditBatch</span> <span class="p">();</span>

                                <span class="n">result</span> <span class="o">=</span> <span class="n">LXe_OK</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="p">}</span>

                        <span class="kt">int</span>
                <span class="n">mop_Compare</span> <span class="p">(</span>
                        <span class="n">ILxUnknownID</span>             <span class="n">other_obj</span><span class="p">)</span>             <span class="n">LXx_OVERRIDE</span>
                <span class="p">{</span>
                        <span class="n">MeshOperation</span>           <span class="o">*</span><span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">dyna_Float</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      Cast the other interface into our implementation, and</span>
<span class="cm">                         *      then compare the offset attribute.</span>
<span class="cm">                         */</span>

                        <span class="n">lx</span><span class="o">::</span><span class="n">CastServer</span> <span class="p">(</span><span class="n">SERVER_NAME</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
                        <span class="p">{</span>
                                <span class="cm">/*</span>
<span class="cm">                                 *      If the offset is identical, we don&#39;t want to</span>
<span class="cm">                                 *      do anything.</span>
<span class="cm">                                 */</span>

                                <span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
                                        <span class="k">return</span> <span class="n">LXiMESHOP_IDENTICAL</span><span class="p">;</span>

                                <span class="cm">/*</span>
<span class="cm">                                 *      As long as neither offset is 0.0, the previous</span>
<span class="cm">                                 *      operation is compatible.</span>
<span class="cm">                                 */</span>

                                <span class="k">if</span> <span class="p">(</span><span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LXi_EQUAL_TO</span> <span class="o">&amp;&amp;</span> <span class="n">lx</span><span class="o">::</span><span class="n">Compare</span> <span class="p">(</span><span class="n">_offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LXi_EQUAL_TO</span><span class="p">)</span>
                                        <span class="k">return</span> <span class="n">LXiMESHOP_COMPATIBLE</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">return</span> <span class="n">LXiMESHOP_DIFFERENT</span><span class="p">;</span>
                <span class="p">}</span>

                        <span class="n">LxResult</span>
                <span class="n">mop_Convert</span> <span class="p">(</span>
                        <span class="n">ILxUnknownID</span>             <span class="n">other_obj</span><span class="p">)</span>             <span class="n">LXx_OVERRIDE</span>
                <span class="p">{</span>
                        <span class="n">MeshOperation</span>           <span class="o">*</span><span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">dyna_Float</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      Cast the other interface into our implementation, and</span>
<span class="cm">                         *      then copy the cached points that want to offset.</span>
<span class="cm">                         */</span>

                        <span class="n">lx</span><span class="o">::</span><span class="n">CastServer</span> <span class="p">(</span><span class="n">SERVER_NAME</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
                        <span class="p">{</span>
                                <span class="n">_points</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>

                                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">_points</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                                <span class="p">{</span>
                                        <span class="n">_points</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">_points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                                <span class="p">}</span>

                                <span class="k">return</span> <span class="n">LXe_OK</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">return</span> <span class="n">LXe_FAILED</span><span class="p">;</span>
                <span class="p">}</span>

                        <span class="n">LxResult</span>
                <span class="n">mop_ReEvaluate</span> <span class="p">(</span>
                        <span class="n">ILxUnknownID</span>             <span class="n">mesh_obj</span><span class="p">,</span>
                        <span class="n">LXtID4</span>                   <span class="n">type</span><span class="p">)</span>                  <span class="n">LXx_OVERRIDE</span>
                <span class="p">{</span>
                        <span class="n">CLxUser_Mesh</span>             <span class="nf">mesh</span> <span class="p">(</span><span class="n">mesh_obj</span><span class="p">);</span>

                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">dyna_Float</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                        <span class="cm">/*</span>
<span class="cm">                         *      Deform the cached points by reapplying the offset.</span>
<span class="cm">                         */</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">OffsetPositions</span> <span class="p">(</span><span class="n">mesh</span><span class="p">)))</span>
                                <span class="k">return</span> <span class="n">mesh</span><span class="p">.</span><span class="n">SetMeshEdits</span> <span class="p">(</span><span class="n">LXf_MESHEDIT_POSITION</span><span class="p">);</span>

                        <span class="k">return</span> <span class="n">LXe_FAILED</span><span class="p">;</span>
                <span class="p">}</span>

                        <span class="n">LxResult</span>
                <span class="n">OffsetPositions</span> <span class="p">(</span>
                        <span class="n">CLxUser_Mesh</span>            <span class="o">&amp;</span><span class="n">mesh</span><span class="p">)</span>
                <span class="p">{</span>
                        <span class="n">CLxUser_Point</span>            <span class="n">point</span><span class="p">;</span>
                        <span class="n">LxResult</span>                 <span class="n">result</span> <span class="o">=</span> <span class="n">LXe_FAILED</span><span class="p">;</span>
                        <span class="kt">int</span>                      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">test</span> <span class="p">())</span>
                        <span class="p">{</span>
                                <span class="n">point</span><span class="p">.</span><span class="n">fromMesh</span> <span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

                                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_points</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                                <span class="p">{</span>
                                        <span class="n">PointData</span>               <span class="o">*</span><span class="n">pointData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                                        <span class="n">LXtVector</span>                <span class="n">pos</span><span class="p">;</span>

                                        <span class="n">pointData</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                                        <span class="k">if</span> <span class="p">(</span><span class="n">LXx_OK</span> <span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">Select</span> <span class="p">(</span><span class="n">pointData</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)))</span>
                                        <span class="p">{</span>
                                                <span class="n">LXx_VCPY</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pointData</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">);</span>
                                                <span class="n">LXx_VSCL</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">_offset</span><span class="p">);</span>
                                                <span class="n">LXx_VADD</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pointData</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">);</span>

                                                <span class="n">point</span><span class="p">.</span><span class="n">SetPos</span> <span class="p">(</span><span class="n">pos</span><span class="p">);</span>
                                        <span class="p">}</span>
                                <span class="p">}</span>

                                <span class="n">result</span> <span class="o">=</span> <span class="n">LXe_OK</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">double</span>                   <span class="n">_offset</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">PointData</span><span class="o">&gt;</span>  <span class="n">_points</span><span class="p">;</span>

                <span class="k">static</span> <span class="n">LXtTagInfoDesc</span>    <span class="n">descInfo</span><span class="p">[];</span>
<span class="p">};</span>

<span class="n">LXtTagInfoDesc</span> <span class="n">MeshOperation</span><span class="o">::</span><span class="n">descInfo</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
        <span class="p">{</span> <span class="n">LXsMESHOP_PMODEL</span><span class="p">,</span>             <span class="s">&quot;.&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">LXsPMODEL_SELECTIONTYPES</span><span class="p">,</span>     <span class="n">LXsSELOP_TYPE_POLYGON</span> <span class="p">},</span>
        <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">initialize</span> <span class="p">()</span>
<span class="p">{</span>
        <span class="n">CLxGenericPolymorph</span>     <span class="o">*</span><span class="n">srv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">srv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CLxPolymorph</span>                                          <span class="o">&lt;</span><span class="n">MeshOperation</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">srv</span><span class="o">-&gt;</span><span class="n">AddInterface</span>               <span class="p">(</span><span class="k">new</span> <span class="n">CLxIfc_MeshOperation</span>       <span class="o">&lt;</span><span class="n">MeshOperation</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="n">srv</span><span class="o">-&gt;</span><span class="n">AddInterface</span>               <span class="p">(</span><span class="k">new</span> <span class="n">CLxIfc_Attributes</span>          <span class="o">&lt;</span><span class="n">MeshOperation</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="n">srv</span><span class="o">-&gt;</span><span class="n">AddInterface</span>               <span class="p">(</span><span class="k">new</span> <span class="n">CLxIfc_StaticDesc</span>          <span class="o">&lt;</span><span class="n">MeshOperation</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="n">lx</span><span class="o">::</span><span class="n">AddServer</span> <span class="p">(</span><span class="n">SERVER_NAME</span><span class="p">,</span> <span class="n">srv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="config">
<h3><a class="toc-backref" href="#id23">Config</a><a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h3>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>

        <span class="c">&lt;!--</span>
<span class="c">                The CommandHelp block is used to define the item and channel usernames.</span>
<span class="c">        --&gt;</span>

        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;CommandHelp&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Item&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item@en_US&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Channel&quot;</span> <span class="na">key=</span><span class="s">&quot;enable&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Enable<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/hash&gt;</span>
                        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Channel&quot;</span> <span class="na">key=</span><span class="s">&quot;offset&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;UserName&quot;</span><span class="nt">&gt;</span>Offset<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/hash&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/atom&gt;</span>

        <span class="c">&lt;!--</span>
<span class="c">                The properties form displays a single property to control the offset.</span>
<span class="c">                The common mesh operation sheet is also included to add the enable</span>
<span class="c">                checkbox to the top of the form.</span>
<span class="c">        --&gt;</span>

        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Attributes&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Sheet&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item:sheet&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Label&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Filter&quot;</span><span class="nt">&gt;</span>sample.bevel.item:filterPreset<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;InCategory&quot;</span> <span class="na">key=</span><span class="s">&quot;itemprops:general#head&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Ordinal&quot;</span><span class="nt">&gt;</span>110<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/hash&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;ref item-common:sheet&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>#0<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/list&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;ref meshoperation:sheet&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>#1<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/list&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Control&quot;</span> <span class="na">val=</span><span class="s">&quot;cmd item.channel sample.bevel.item$offset ?&quot;</span><span class="nt">&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Label&quot;</span><span class="nt">&gt;</span>Offset<span class="nt">&lt;/atom&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;StartCollapsed&quot;</span><span class="nt">&gt;</span>0<span class="nt">&lt;/atom&gt;</span>
                                <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Hash&quot;</span><span class="nt">&gt;</span>sample.bevel.item.offset.ctrl:control<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/atom&gt;</span>

        <span class="c">&lt;!--</span>
<span class="c">                A filter determines when the properties form should be displayed. In this</span>
<span class="c">                case the properties form should be displayed when the sample.bevel.item</span>
<span class="c">                item type is selected.</span>
<span class="c">        --&gt;</span>

        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Filters&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Preset&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item:filterPreset&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Name&quot;</span><span class="nt">&gt;</span>Bevel Sample<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Description&quot;</span><span class="nt">&gt;&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span><span class="nt">&gt;</span>pmodel:filterCat<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Enable&quot;</span><span class="nt">&gt;</span>1<span class="nt">&lt;/atom&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>1 .group 0 <span class="ni">&amp;quot;&amp;quot;</span><span class="nt">&lt;/list&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>1 itemtype 0 1 <span class="ni">&amp;quot;</span>sample.bevel.item<span class="ni">&amp;quot;</span><span class="nt">&lt;/list&gt;</span>
                        <span class="nt">&lt;list</span> <span class="na">type=</span><span class="s">&quot;Node&quot;</span><span class="nt">&gt;</span>-1 .endgroup <span class="nt">&lt;/list&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/atom&gt;</span>

        <span class="c">&lt;!--</span>
<span class="c">                The categories define which sub-category the mesh operation will appear</span>
<span class="c">                in. Two categories have to be set, one that shows all Mesh Operations</span>
<span class="c">                and another which is filtered to show only operations that support a</span>
<span class="c">                specific selection type.</span>
<span class="c">        --&gt;</span>

        <span class="nt">&lt;atom</span> <span class="na">type=</span><span class="s">&quot;Categories&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span> <span class="na">key=</span><span class="s">&quot;MeshOperations&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;C&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item&quot;</span><span class="nt">&gt;</span>polygon<span class="nt">&lt;/hash&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>

                <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;Category&quot;</span> <span class="na">key=</span><span class="s">&quot;MeshOperationsPolygons&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;hash</span> <span class="na">type=</span><span class="s">&quot;C&quot;</span> <span class="na">key=</span><span class="s">&quot;sample.bevel.item&quot;</span><span class="nt">&gt;</span>polygon<span class="nt">&lt;/hash&gt;</span>
                <span class="nt">&lt;/hash&gt;</span>
        <span class="nt">&lt;/atom&gt;</span>

<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Mesh%20Operation%20-%20Manual%20implementation.html" class="btn btn-neutral float-right" title="Mesh Operation - Manual implementation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Mesh%20Operation%20-%20Automatic%20implementation.html" class="btn btn-neutral float-left" title="Mesh Operation - Automatic implementation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Foundry

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>

<!-- Mirrored from learn.foundry.com/modo/developers/latest/sdk/pages/tutorials/Mesh Operation - Example.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 30 Nov 2024 03:16:08 GMT -->
</html>